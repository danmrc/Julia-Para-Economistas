<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <!-- Un-minified script so that can play a bit -->
<link rel="stylesheet" href="/libs/katex/katex.min.css">
     
  
  <link rel="stylesheet" href="/css/judoc.css">
  <link rel="stylesheet" href="/css/pure.css">
  <link rel="stylesheet" href="/css/side-menu.css">
  <!-- style adjustments -->
  <style>
    .jd-content{padding-left:10%;}
    @media (min-width: 940px) {
      .jd-content {width: 640px; margin-left: 0px; padding-left: 80px;}
      .header {width: 700px;}
    }
  </style>
  <link rel="icon" href="/assets/infra/favicon.png">
   <title>Funções</title>  
</head>
<body>
  <div id="layout">
    <!-- Menu toggle / hamburger icon -->
    <a href="#menu" id="menuLink" class="menu-link"><span></span></a>
    <div id="menu">
      <div class="pure-menu">
        <a class="pure-menu-heading" href="#">Jl para Econ</a>
        <ul class="pure-menu-list">
          <li class="pure-menu-item "><a href="/" class="pure-menu-link">Home</a></li>
          <li class="pure-menu-item "><a href="/pub/Instalando.html" class="pure-menu-link">Instalando</a></li>
          <li class="pure-menu-item "><a href="/pub/primeirospassos.html" class="pure-menu-link">Primeiros Passos</a></li>
          <li class="pure-menu-item "><a href="/pub/graficos.html" class="pure-menu-link">Gráficos</a></li>
          <li class="pure-menu-item "><a href="/pub/mat.html" class="pure-menu-link">Matemática I</a></li>
          <li class="pure-menu-item "><a href="/pub/matII.html" class="pure-menu-link">Matemática II</a></li>
          <li class="pure-menu-item "><a href="/pub/Controledefluxo.html" class="pure-menu-link">Controle de Fluxo</a></li>
          <li class="pure-menu-item "><a href="/pub/foos.html" class="pure-menu-link">Funções</a></li>
          <li class="pure-menu-item "><a href="/pub/misc.html" class="pure-menu-link">Miscelânea</a></li>
        </ul>
      </div>
    </div>
    <div id="main"> <!-- Closed in foot -->
      <div class="header">
        <h1>Funções</h1>
        <h2>Using the Pure/Side-Menu template</h2>
      </div>

<!-- Content appended here -->

<div class="jd-content">
<p>Nós já construímos funções matemáticas simples anteriormente. Aqui, nós vamos nos aprofundar em como construir funções mais complexas, que não necessariamente são uma única operação matemática, mas podem ser um conjunto de instruções para o computador.</p>
<p>Eu temo que essa seção seja excessivamente abstrata. Eu peço desculpas ao leitor que é novo em programação e não consegue ver exatamente porque todos esses tópicos são interessantes. O exemplo promete mostrar muitas das coisas que desenvolvemos aqui sendo aplicadas - espero que ela justifique os tópicos apresentados.</p>
<h1><a id="reviso_funes_matemticas" href="#reviso_funes_matemticas">Revisão: funções matemáticas</a></h1> Nós vimos que a sintaxe para escrever uma função matemática no Julia era bastante simples: nós escrevemos como nós escreveríamos no papel.</p>
<pre><code class="language-julia">f(x) = x^2
</code></pre>
<p>Isso vale para funções com mais de uma variável também:</p>
<pre><code class="language-julia">f(x,y) = x^2+y^2
</code></pre>
<h1><a id="funes_usando_o_function" href="#funes_usando_o_function">Funções usando o <em>function</em></a></h1> Agora, podemos querer fazer funções que são mais complicadas: elas podem envolver uma série de operações que não podem ser descritas com uma única linha. Nesse caso, usamos o comando <code>function</code>:</p>
<pre><code class="language-julia">function foo(args)
  operações
end
</code></pre>
<p>Isso vai gerar uma função com nome <code>foo</code>. Vamos refazer \(f(x,y)\) usando esse formato apenas para termos um exemplo concreto:</p>
<pre><code class="language-julia">function f(x,y)
  x^2+y^2
end
</code></pre>
<p>Veja que isso não é a verdadeira utilidade dessa maneira de escrever a função. A grande vantagem é poder passar várias linhas de código. Por exemplo, uma função boba que nos diz se um número é positivo ou negativo pode ser escrita:</p>
<pre><code class="language-julia">function f(x)
  if x > 0
    print("Positivo")
  elseif x < 0
    print("Negativo")
  else
    print("Zero")
  end
end
</code></pre>
<p>Onde nós exploramos o if na parte de <a href="/pub/Controledefluxo.html">controle de fluxo</a>. Veja que da maneira que foi escrito, se você passar algo não númerico, ele vai informar que é zero. Nós podemos contornar esse problema de duas maneiras:</p>
<ol>
<li><p>Colocando um if que testa se é númerico</p>
</li>
<li><p>Limitando o tipo de input que a função recebe. Veja que isso é meio matar uma mosca com um tiro de canhão, mas é uma ilustração útil dessa opção. Vamos limitar a função para x só poder ser do tipo <code>Float64</code>:</p>
</li>
</ol>
<pre><code class="language-julia">function f(x::Float64)
  if x > 0
    print("Positivo")
  elseif x < 0
    print("Negativo")
  else
    print("Zero")
  end
end
</code></pre>
<p>Veja que se passarmos o número 1, o Julia retorna um erro de que o tipo não está certo. Uma coisa legal do Julia é que nós podemos definir a <em>mesma função duas vezes com tipos diferentes</em>:</p>
<pre><code class="language-julia">function f(x::Int64)
  if x > 0
    print("Positivo")
  elseif x < 0
    print("Negativo")
  else
    print("Zero")
  end
end
</code></pre>
<p>Agora, co-existem dois tipos de <code>f</code>: uma que é chamada se o input é um <code>Int64</code> e outra se o input for <code>Float64</code>.</p>
<h2><a id="return" href="#return"><em>Return</em></a></h2> Suponha que escrevemos uma função que faz várias coisas e queremos que ela retorne apenas um resultado. Isso é bastante frequente: talvez tenhamos um loop dentro da função e queremos retornar um array criado no loop. Para isso usamos a <em>keyword</em> return:</p>
<pre><code class="language-julia">function foo(args)
  um monte de coisa
  return resultado
end
</code></pre>
<p>Uma característica do Julia é que - assim como o matlab, mas diferentemente do R - uma função pode retornar vários objetos:</p>
<pre><code class="language-julia">function foo(args)
  um monte de coisa
  return resultado1, resultado2...
end
</code></pre>
<p>Se você criar vários objetos ao chamar a função, cada objeto vai receber um resultado:</p>
<pre><code class="language-julia">res1,res2 = foo(args)
</code></pre>
<p>Um comportamento curioso é que se você pede para a função retornar \(n\) coisas e só passa um objeto ele retorna tudo em um único objeto. Eu vou deixar \(n=3\):</p>
<pre><code class="language-julia">function foo2(args)
  um monte de coisa
  return resultado1, resultado2,resultado3
end

res = foo2(args)
</code></pre>
<p>Nesse caso, res vai ter resultado1, resultado2 e resultado3. Já se passarmos dois objetos, ele vai retornar os dois primeiros resultados e jogar o terceiro fora:</p>
<pre><code class="language-julia">res1,res2 = foo2(args)
</code></pre>
<p>Agora <code>res1</code> contém <code>resultado1</code> e <code>res2</code> contém <code>resultado2</code>
<h1><a id="argumentos_ordem_e_nome" href="#argumentos_ordem_e_nome">Argumentos: ordem e nome</a></h1> Outra coisa peculiar do Julia é que os argumentos devem ser passados na ordem em que eles foram escritos na função e sem o nome. Assim:</p>
<pre><code class="language-julia">foo(a,b,c)
  função
end

foo(val_a,val_b,val_c)
</code></pre>
<p>Veja que se você passar o valor de b&#40;<code>val_b</code>&#41; na primeira posição, ele vai usar isso no argumento a. Isso pode ser um desastre se você é desorganizado <em>e</em> não lembra da ordem que colocou os argumento - o que certamente é o caso do autor deste manual. Nesse caso, pode ser conveniente ter como escrever qual argumento você está usando &#40;como é o padrão do R, por exemplo&#41;. Para isso, ao definir a função, usamos o <code>;</code>. Os argumentos depois do <code>;</code> <em>obrigatoriamente</em> tem que ser chamados com o nome. A divisão de argumentos depois se dá normalmente, usando a vírgula. Assim, poderíamos reescrever a função <code>foo</code> acima:</p>
<pre><code class="language-julia">foo(;a,b,c)
  função
end

foo(b = val_b,a = val_a,c = val_c)
</code></pre>
<p>Veja que podemos misturar argumentos que devem ser chamados com nome e chamados sem o nome:</p>
<pre><code class="language-julia">foo(a,b;c,d)
  função
end

foo(val_a,val_b,d = val_d,c = val_c)
</code></pre>
<h1><a id="exemplo" href="#exemplo">Exemplo</a></h1> <pre><code class="language-julia">function solve_lypaunov(A,Sigma;tol=1e-6,iter_max=100)
  err = 1
  j = 1
  sol = I
  while j <= iter_max && err > tol
  old_sol = sol
  sol = A*old_sol*A' + Sigma
  j += 1
  err = maximum(abs.(old_sol-sol))
  end
  return sol,j,err
end

A=[0.5 0.2;-0.4 0.6]

solucao,tentativa,err = solve_lypaunov(A,I)
solucao = solve_lypaunov(A,I)
solucao,resto = solve_lypaunov(A,I)
solucao,resto = solve_lypaunov(A,I, iter_max=500, tol = 1e-10)
</code></pre></p>

<div class="page-foot">
  <div class="copyright">
    &copy; Daniel Coutinho. Last modified: July 24, 2019. Website built with <a href="https://github.com/tlienart/JuDoc.jl">JuDoc.jl</a>.
  </div>
</div>

</div>
<!-- CONTENT ENDS HERE -->
      </div> <!-- end of id=main -->
  </div> <!-- end of id=layout -->
  <script src="/libs/pure/ui.min.js"></script>
  
      <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

  
  
</body>
</html>
