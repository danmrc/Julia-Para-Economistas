<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Julia-Para-Economistas/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Julia-Para-Economistas/css/judoc.css"> <link rel=stylesheet  href="/Julia-Para-Economistas/css/pure.css"> <link rel=stylesheet  href="/Julia-Para-Economistas/css/side-menu.css"> <style> .jd-content{padding-left:10%;} @media (min-width: 940px) { .jd-content {width: 640px; margin-left: 0px; padding-left: 80px;} .header {width: 700px;} } </style> <link rel=icon  href="/Julia-Para-Economistas/assets/infra/favicon.png"> <title>Matemática no Julia I</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">Jl para Econ</a> <ul class=pure-menu-list > <li class="pure-menu-item "><a href="/Julia-Para-Economistas/" class=pure-menu-link >Home</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/Instalando.html" class=pure-menu-link >Instalando</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/primeirospassos.html" class=pure-menu-link >Primeiros Passos</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/graficos.html" class=pure-menu-link >Gráficos</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/Controledefluxo.html" class=pure-menu-link >Controle de Fluxo</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/mat.html" class=pure-menu-link >Matemática no Julia</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/misc.html" class=pure-menu-link >Miscelânea</a> </ul> </div> </div> <div id=main > <div class=header > <h1>Matemática no Julia I</h1> <h2>Using the Pure/Side-Menu template</h2> </div> <div class=jd-content > <p>Nessa seção vamos focar nas ferramentas matemáticas que serão úteis para a gente no Julia. Elas em geral vem em forma de pacotes. Nós vamos focar em : otimização, achar a raiz e . Os pacotes que vamos usar são o <strong>Optim</strong>, o <strong>Roots</strong> e o <strong>Interpolations</strong>. Eu também vou tratar sumariamente de fazer gráficos no Julia - que são sempre de grande valia para analisar problemas. Para saber mais sobre gráficos, visite a parte de <a href="/Julia-Para-Economistas/pub/graficos.html">gráficos</a></p> <h1><a id=optim  href="#optim">Optim</a></h1> Nós já tivemos um primeiro encontro com o Optim em um momento anterior. O Optim faz otimização tanto em funções de uma variável quanto em funções de várias variáveis. Vamos começar com o exemplo que eu já dei:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Optim

f(x) = x^<span class=hljs-number >2</span>

optimize(f,-<span class=hljs-number >1</span>,<span class=hljs-number >1</span>)
</code></pre> <p>O comando <code>optimize</code> recebe tres argumentos quando buscamos o ótimo de uma função de uma variável: a função, o menor valor do intervalo a ser buscado e o maior valor. Nesse caso, buscamos o mínimo da função f entre -1 e 1. Veja que o comando sempre busca o mínimo: para encontrar o máximo de uma função, basta multiplicar a função por -1. Vamos procurar o máximo da função <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{1+x^2}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.845108em;"><span style="top:-2.655em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> , que tem a seguinte cara:</p> <p><img src="/Julia-Para-Economistas/src/imagens/logistica.png" alt="" /></p> <p>Veja que como queremos o máximo, vamos ter que multiplicar a função por -1. Eu vou definir ela direto com um menos na frente:</p> <pre><code class="julia hljs">l(x) = -<span class=hljs-number >1</span>/(<span class=hljs-number >1</span>+x^<span class=hljs-number >2</span>)
optimize(l,-<span class=hljs-number >2</span>,<span class=hljs-number >2</span>)
</code></pre> <p>Veja que dessa vez eu deixei o intervalo maior, mas o optimize não deve ter problemas em conseguir achar o mínimo - que no nosso caso é o máximo.</p> <p>Veja que podemos querer encontrar o ótimo de uma função de várias variáveis. O Optim também nos dá essa possibilidade. Por exemplo, podemos querer achar o mínimo da função <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>z</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">z=x^2+y^2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.897438em;vertical-align:-0.08333em;"></span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.008548em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> - que tem o mínimo em &#40;0,0&#41;. Veja que precisamos passar o x e o y como um único elemento em formato de vetor então a função vai ser escrita de maneira um pouco esquisita da segunte forma:</p> <pre><code class="julia hljs">f(x)=x[<span class=hljs-number >1</span>]^<span class=hljs-number >2</span>+x[<span class=hljs-number >2</span>]^<span class=hljs-number >2</span>
</code></pre> <p>&#40;Em um pequeno aparte, vale a pena notar que esse mesmo formato de escrever a função para otimizar é utilizado no R&#41;</p> <p>A função <code>optimize</code> agora recebe a função e um chute inicial, na forma de uma array com o mesmo número de argumentos que a função recebe - nesse caso, 2:</p> <pre><code class="julia hljs">sol = optimize(f,[<span class=hljs-number >1</span>,<span class=hljs-number >1</span>])
</code></pre> <p>Obviamente um bom chute implica em uma solução melhor. Se dermos um chute em &#40;0,0&#41;, o algoritmo não deve fazer nada:</p> <pre><code class="julia hljs">sol = optimize(f,[<span class=hljs-number >0</span>,<span class=hljs-number >0</span>])
</code></pre> <p>Veja que podemos mudar o algoritmo de otimização. Em geral se usa o Nelder-Mead, que funciona bem para funções não diferenciáveis. Como no nosso caso a função é diferenciável, podemos usar algum outro algoritmo, como o BFGS:</p> <pre><code class="julia hljs">sol = optimize(f,[<span class=hljs-number >0</span>,<span class=hljs-number >0</span>],BFGS())
</code></pre> <p>Veja que o nome do algoritmo é chamado como se fosse uma função sem argumentos.</p> <h1><a id=roots  href="#roots">Roots</a></h1> O pacote <strong>roots</strong> permite achar raízes de funções univariadas. Existem quatro maneiras de chamar o comando, mas todos recebem as mesma opções. Vamos tentar achar o zero da função <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x+1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span> &#40;que convenientemente tem zero em <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>x</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x=-1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >−</span><span class=mord >1</span></span></span></span> &#41;. Vamos usar a função <code>fzero</code> para encontrar o zero dessa função. Ele recebe a função e o limite inferior e o superior para buscar o zero:</p> <pre><code class="julia hljs">g(x) = x-<span class=hljs-number >1</span>
zer = fzero(g,-<span class=hljs-number >2</span>,<span class=hljs-number >0</span>)
</code></pre> A outra opção é usar a função <code>find_zero</code>, que tem sintaxe igual; as funções <code>fzeros</code> e <code>find_zeros</code>, no plural, buscam <em>todos</em> os zeros. Elas são significativamente mais lentas na minha experiência e se voce sabe que o problema só tem um zero - pelo menos dentro da região em que ele está buscando - voce ganha em usar o <code>fzero</code> ou o <code>find_zero</code>.</p> <p>Veja que o fato da sintaxe ser parecida com a otimização em uma variável não é mera coinciência: quando otimizamos na mão usando os métodos de cálculo, buscamos o zero da derivada da função <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> . Logo, as semelhanças vão bem além da superfíce do problema.</p> <h1><a id=interpolations  href="#interpolations">Interpolations</a></h1> O pacote <strong>Interpolations</strong> permite fazer interpolação. A ideia de interpolação é ligar os pontos de alguma maneira. Os Mínimos Quadrados Ordinários &#40;MQO&#41; de econometria são, de certa maneira, um algoritmo de interpolação. Nós também poderíamos querer ligar os pontos de maneira que a nossa função fosse exatamente o valor do ponto - lembre-se que no MQO a reta de regressão em geral não passa exatamente em cima do ponto.</p> <p>Uma maneira possível de fazer interpolação é, se temos <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> pontos, podemos construir um polinômio de grau <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span> que passe por todos os pontos. Essa não é uma <a href="https://azul.netlify.com/2018/08/27/interpolacao/">estratégia muito boa</a>: funções simples podem ter aproximações horrorosas por polinômios.</p> <p>Uma maneira extremamente simples - e fantasticamente útil - de fazer interpolação é &quot;ligar os pontos&quot;, como em um livro infátil. Ligue os pontos usando retas. Fazer isso com o <strong>Interpolations</strong> é bastante simples. Podemos querer aproximar a função <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{1+x^2}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.845108em;"><span style="top:-2.655em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class=pstrut  style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> por retas. O comando <code>LinearInterpolation</code> faz isso para gente. Eu vou gerar 10 pontos equidistantes entre -5 e 5 em um vetor <code>xx</code> e avaliar a função e salvar isso no vetor <code>yy</code>. Depois, eu vou usar o <code>LinearInterpolation</code> para gerar uma função que é a interpolação linear:</p> <pre><code class="julia hljs">f(x) = <span class=hljs-number >1</span>/(<span class=hljs-number >1</span>+x^<span class=hljs-number >2</span>)

xx = range(-<span class=hljs-number >5</span>,<span class=hljs-number >5</span>, length = <span class=hljs-number >10</span>)

lin = LinearInterpolation(xx,yy)
</code></pre> <p>Veja que <code>lin</code> é uma função: podemos fazer <code>lin&#40;0.5&#41;</code>,por exemplo. Vamos avaliar a qualidade dessa interpolação. Para isso vamos definir uma grade mais fina e avaliar a função e a interpolação:</p> <pre><code class="julia hljs">x = -<span class=hljs-number >5</span>:<span class=hljs-number >0.01</span>:<span class=hljs-number >5</span>
plot(x,f.(x), label = <span class=hljs-string >"Função"</span>)
plot!(x,lin.(x), line = :dash, label = <span class=hljs-string >"Aproximação"</span>)
</code></pre> <p><img src="/Julia-Para-Economistas/src/imagens/lin_interpol1.png" alt="" /></p> <p>Veja que a aproximação é bastante pouca precisa. Aumentar o número de pontos para 50 melhora bastante a situação:</p> <pre><code class="julia hljs">xx = range(-<span class=hljs-number >5</span>,<span class=hljs-number >5</span>,length = <span class=hljs-number >50</span>)

yy = f.(xx)

lin = LinearInterpolation(xx,yy)

plot(x,f.(x), label = <span class=hljs-string >"Função"</span>)
plot!(x,lin.(x), line = :dash, label = <span class=hljs-string >"Aproximação"</span>)
</code></pre> <img src="/Julia-Para-Economistas/src/imagens/lin_interpol2.png" alt="" /></p> <p>Agora a aproximação é bem melhor - apesar de ser apenas um conjunto de retas.</p> <p>Às vezes queremos permitir que a função extrapole, i.e., avalie fora da grade que estabelecemos. Para isso, podemos usar a opção <code>extrapolation_bc</code> dentro do <code>LinearInterpolation</code>. Ele aceita várias opções: <code>Flat&#40;&#41;</code> repete o último valor; <code>Line&#40;&#41;</code> extrapola linearmente, entre outras opções. Eu vou continuar usando a mesma função e focar no que acontece na ponta esquerda quando usamos <code>Flat&#40;&#41;</code> e quando usamos <code>Line&#40;&#41;</code>. Na ponta direita a figura é idêntica:</p> <pre><code class="julia hljs">x = -<span class=hljs-number >7</span>:<span class=hljs-number >0.01</span>:-<span class=hljs-number >4</span>

lin1 = LinearInterpolation(xx,yy, extrapolation_bc = Flat())
lin2 = LinearInterpolation(xx,yy,extrapolation_bc = Line())

plot(x,f.(x), label = <span class=hljs-string >"Função"</span>, legend =:topleft)
plot!(x,lin1.(x), line = :dash,w=<span class=hljs-number >2</span>, label = <span class=hljs-string >"Flat()"</span>)
plot!(x,lin2.(x), line = :dash,w=<span class=hljs-number >2</span>, label = <span class=hljs-string >"Line()"</span>)
</code></pre> <img src="/Julia-Para-Economistas/src/imagens/lin_interpol3.png" alt="" /></p> <p>Nós também podemos querer gerar interpolações de funções que estão definidas não em <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi mathvariant=double-struck >R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68889em;vertical-align:0em;"></span><span class=mord ><span class="mord mathbb">R</span></span></span></span></span> , mas em <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msup><mi mathvariant=double-struck >R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord ><span class=mord ><span class="mord mathbb">R</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> ou <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msup><mi mathvariant=double-struck >R</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^3</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord ><span class=mord ><span class="mord mathbb">R</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> . Nesse caso, o comando passa a ser:</p> <pre><code class="julia hljs">LinearInterpolation((x,y),z)
</code></pre> <p>Onde <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mo stretchy=false >(</mo><mi>x</mi><mo separator=true >,</mo><mi>y</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathdefault">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class=mclose >)</span></span></span></span> são vetores de tamanho <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathdefault">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathdefault">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , respectivamente, e z é uma matriz <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>×</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_1 \times n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.73333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathdefault">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathdefault">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> .</p> <div class=page-foot > <div class=copyright > &copy; Daniel Coutinho. Last modified: July 13, 2019. Website built with <a href="https://github.com/tlienart/JuDoc.jl">JuDoc.jl</a>. </div> </div> </div> </div> </div> <script src="/Julia-Para-Economistas/libs/pure/ui.min.js"></script>