<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/Julia-Para-Economistas/libs/katex/katex.min.css"> <link rel=stylesheet  href="/Julia-Para-Economistas/css/judoc.css"> <link rel=stylesheet  href="/Julia-Para-Economistas/css/pure.css"> <link rel=stylesheet  href="/Julia-Para-Economistas/css/side-menu.css"> <style> .jd-content{padding-left:10%;} @media (min-width: 940px) { .jd-content {width: 640px; margin-left: 0px; padding-left: 80px;} .header {width: 700px;} } </style> <link rel=icon  href="/Julia-Para-Economistas/assets/infra/favicon.png"> <title>Funções</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">Jl para Econ</a> <ul class=pure-menu-list > <li class="pure-menu-item "><a href="/Julia-Para-Economistas/" class=pure-menu-link >Home</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/Instalando.html" class=pure-menu-link >Instalando</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/primeirospassos.html" class=pure-menu-link >Primeiros Passos</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/graficos.html" class=pure-menu-link >Gráficos</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/mat.html" class=pure-menu-link >Matemática I</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/matII.html" class=pure-menu-link >Matemática II</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/Controledefluxo.html" class=pure-menu-link >Controle de Fluxo</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/foos.html" class=pure-menu-link >Funções</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/progdyn.html" class=pure-menu-link >Ex: Prog Dinâmica</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/misc.html" class=pure-menu-link >Miscelânea</a> <li class="pure-menu-item "><a href="/Julia-Para-Economistas/pub/biblio.html" class=pure-menu-link >Bibliografia</a> </ul> </div> </div> <div id=main > <div class=header > <h1>Funções</h1> <h2>Julia Para Economistas</h2> </div> <div class=jd-content > <p>Nós já construímos funções matemáticas simples anteriormente. Aqui, nós vamos nos aprofundar em como construir funções mais complexas, que não necessariamente são uma única operação matemática, mas podem ser um conjunto de instruções para o computador.</p> <p>Eu temo que essa seção seja excessivamente abstrata. Eu peço desculpas ao leitor que é novo em programação e não consegue ver exatamente porque todos esses tópicos são interessantes. O exemplo promete mostrar muitas das coisas que desenvolvemos aqui sendo aplicadas - espero que ela justifique os tópicos apresentados.</p> <h1><a id=reviso_funes_matemticas  href="#reviso_funes_matemticas">Revisão: funções matemáticas</a></h1> Nós vimos que a sintaxe para escrever uma função matemática no Julia era bastante simples: nós escrevemos como nós escreveríamos no papel.</p> <pre><code class="julia hljs">f(x) = x^<span class=hljs-number >2</span>
</code></pre> <p>Isso vale para funções com mais de uma variável também:</p> <pre><code class="julia hljs">f(x,y) = x^<span class=hljs-number >2</span>+y^<span class=hljs-number >2</span>
</code></pre> <h1><a id=funes_usando_o_function  href="#funes_usando_o_function">Funções usando o <em>function</em></a></h1> Agora, podemos querer fazer funções que são mais complicadas: elas podem envolver uma série de operações que não podem ser descritas com uma única linha. Nesse caso, usamos o comando <code>function</code>:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo(args)
  operações
<span class=hljs-keyword >end</span>
</code></pre> <p>Isso vai gerar uma função com nome <code>foo</code>. Vamos refazer <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo separator=true >,</mo><mi>y</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">f(x,y)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathdefault">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class=mclose >)</span></span></span></span> usando esse formato apenas para termos um exemplo concreto:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> f(x,y)
  x^<span class=hljs-number >2</span>+y^<span class=hljs-number >2</span>
<span class=hljs-keyword >end</span>
</code></pre> <p>Veja que isso não é a verdadeira utilidade dessa maneira de escrever a função. A grande vantagem é poder passar várias linhas de código. Por exemplo, uma função boba que nos diz se um número é positivo ou negativo pode ser escrita:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> f(x)
  <span class=hljs-keyword >if</span> x &gt; <span class=hljs-number >0</span>
    print(<span class=hljs-string >"Positivo"</span>)
  <span class=hljs-keyword >elseif</span> x &lt; <span class=hljs-number >0</span>
    print(<span class=hljs-string >"Negativo"</span>)
  <span class=hljs-keyword >else</span>
    print(<span class=hljs-string >"Zero"</span>)
  <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
</code></pre> <p>Onde nós exploramos o if na parte de <a href="/Julia-Para-Economistas/pub/Controledefluxo.html">controle de fluxo</a>. Veja que da maneira que foi escrito, se você passar algo não númerico, ele vai informar que é zero. Nós podemos contornar esse problema de duas maneiras:</p> <ol> <li><p>Colocando um if que testa se é númerico</p> <li><p>Limitando o tipo de input que a função recebe. Veja que isso é meio matar uma mosca com um tiro de canhão, mas é uma ilustração útil dessa opção. Vamos limitar a função para x só poder ser do tipo <code>Float64</code>:</p> </ol> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> f(x::<span class=hljs-built_in >Float64</span>)
  <span class=hljs-keyword >if</span> x &gt; <span class=hljs-number >0</span>
    print(<span class=hljs-string >"Positivo"</span>)
  <span class=hljs-keyword >elseif</span> x &lt; <span class=hljs-number >0</span>
    print(<span class=hljs-string >"Negativo"</span>)
  <span class=hljs-keyword >else</span>
    print(<span class=hljs-string >"Zero"</span>)
  <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
</code></pre> <p>Veja que se passarmos o número 1, o Julia retorna um erro de que o tipo não está certo. Uma coisa legal do Julia é que nós podemos definir a <em>mesma função várias vezes com tipos diferentes</em>:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> f(x::<span class=hljs-built_in >Int64</span>)
  <span class=hljs-keyword >if</span> x &gt; <span class=hljs-number >0</span>
    print(<span class=hljs-string >"Positivo"</span>)
  <span class=hljs-keyword >elseif</span> x &lt; <span class=hljs-number >0</span>
    print(<span class=hljs-string >"Negativo"</span>)
  <span class=hljs-keyword >else</span>
    print(<span class=hljs-string >"Zero"</span>)
  <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
</code></pre> <p>Agora, co-existem dois tipos de <code>f</code>: uma que é chamada se o input é um <code>Int64</code> e outra se o input for <code>Float64</code>.</p> <h2><a id=return  href="#return"><em>Return</em></a></h2> Suponha que escrevemos uma função que faz várias coisas e queremos que ela retorne apenas um resultado. Isso é bastante frequente: talvez tenhamos um loop dentro da função e queremos retornar um array criado no loop. Para isso usamos a <em>keyword</em> return:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo(args)
  um monte de coisa
  <span class=hljs-keyword >return</span> resultado
<span class=hljs-keyword >end</span>
</code></pre> <p>Uma característica do Julia é que - assim como o matlab, mas diferentemente do R - uma função pode retornar vários objetos:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo(args)
  um monte de coisa
  <span class=hljs-keyword >return</span> resultado1, resultado2...
<span class=hljs-keyword >end</span>
</code></pre> <p>Se você criar vários objetos ao chamar a função, cada objeto vai receber um resultado:</p> <pre><code class="julia hljs">res1,res2 = foo(args)
</code></pre> <p>Um comportamento curioso é que se você pede para a função retornar <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> coisas e só passa um objeto ele retorna tudo em um único objeto. Eu vou deixar <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n=3</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >3</span></span></span></span> :</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> foo2(args)
  um monte de coisa
  <span class=hljs-keyword >return</span> resultado1, resultado2,resultado3
<span class=hljs-keyword >end</span>

res = foo2(args)
</code></pre> <p>Nesse caso, res vai ter resultado1, resultado2 e resultado3. Já se passarmos dois objetos, ele vai retornar os dois primeiros resultados e jogar o terceiro fora:</p> <pre><code class="julia hljs">res1,res2 = foo2(args)
</code></pre> <p>Agora <code>res1</code> contém <code>resultado1</code> e <code>res2</code> contém <code>resultado2</code> <h1><a id=argumentos_ordem_nome_e_default  href="#argumentos_ordem_nome_e_default">Argumentos: ordem, nome e default</a></h1> Outra coisa peculiar do Julia é que os argumentos devem ser passados na ordem em que eles foram escritos na função e sem o nome. Assim:</p> <pre><code class="julia hljs">foo(a,b,c)
  função
<span class=hljs-keyword >end</span>

foo(val_a,val_b,val_c)
</code></pre> <p>Veja que se você passar o valor de b&#40;<code>val_b</code>&#41; na primeira posição, ele vai usar isso no argumento a. Isso pode ser um desastre se você é desorganizado <em>e</em> não lembra da ordem que colocou os argumento - o que certamente é o caso do autor deste manual. Nesse caso, pode ser conveniente ter como escrever qual argumento você está usando &#40;como é o padrão do R, por exemplo&#41;. Para isso, ao definir a função, usamos o <code>;</code>. Os argumentos depois do <code>;</code> <em>obrigatoriamente</em> tem que ser chamados com o nome. A divisão de argumentos depois se dá normalmente, usando a vírgula. Assim, poderíamos reescrever a função <code>foo</code> acima:</p> <pre><code class="julia hljs">foo(;a,b,c)
  função
<span class=hljs-keyword >end</span>

foo(b = val_b,a = val_a,c = val_c)
</code></pre> <p>Veja que podemos misturar argumentos que devem ser chamados com nome e chamados sem o nome:</p> <pre><code class="julia hljs">foo(a,b;c,d)
  função
<span class=hljs-keyword >end</span>

foo(val_a,val_b,d = val_d,c = val_c)
</code></pre> <p>Muitas vezes, para facilitar a vida do usuário, queremos colocar valores padrões para a função. Por exemplo, o algoritmo de otimização está implícito no comando <code>optimize</code>. Nós podemos fazer isso no Julia simplesmente colocando um <code>&#61;</code> no argumento da função e um valor ao escrever a função. Por exemplo, uma função que soa dois números, a e b. Eu vou fazer de forma que se não passarmos nenhum valor para b, <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b = 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span> :</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> soma(a,b=<span class=hljs-number >0</span>)
  a+b
<span class=hljs-keyword >end</span>
</code></pre> <h1><a id=exemplo  href="#exemplo">Exemplo</a></h1> Vamos colocar todas as ideias dessa página e mais algumas da seção de <a href="/Julia-Para-Economistas/pubs/Controledefluxo.html">controle de fluxo</a> para construir uma função que resolve a <a href="https://en.wikipedia.org/wiki/Lyapunov_equation">Equação de Lyapunov</a>. Esta equação aparece com frequência em problemas econômicos e resolver é bem simples. Como motivação, considere o VAR &#40;<em>Vector Autoregression</em>, não o árbitro de vídeo&#41;:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>x</mi><mi>t</mi></msub><mo>+</mo><msub><mi>u</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">x_{t+1} = Ax_t + u_t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.638891em;vertical-align:-0.208331em;"></span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathdefault">u</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> <p>Onde <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi>u</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">u_t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathdefault">u</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> é um erro estocástico com variância dada pela matriz <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi mathvariant=normal >Σ</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_u</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Σ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> . Se nós quisermos a variância de <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{t+1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.638891em;vertical-align:-0.208331em;"></span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> , teremos:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=false >)</mo><mo>=</mo><mi>A</mi><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy=false >)</mo><msup><mi>A</mi><mo mathvariant=normal >′</mo></msup><mo>+</mo><msub><mi mathvariant=normal >Σ</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">Var(x_{t+1}) = AVar(x_t)A^{\prime} + \Sigma_u</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.051892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mord ><span class="mord mathdefault">A</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Σ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> <p>Se o processo é estacionário &#40;o que exige algumas condições sobre a matriz A&#41;, então <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy=false >)</mo><mo>=</mo><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">Var(x_{t+1}) = Var(x_t)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> - nós vamos também chamar <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">Var(x_t)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> de <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi mathvariant=normal >Σ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Σ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> . Veja que como produto matricial não comuta, nós não conseguimos colocar <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>t</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">Var(x_t)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class=mopen >(</span><span class=mord ><span class="mord mathdefault">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> em evidência.</p> <p>Uma estratégia para resolver esse problema é iterar a seguinte equação &#40;eu li essa solução em um artigo famoso, <a href="https://doi.org/10.1016/0165-1765&#40;86&#41;90168-0">Tauchen &#40;1986&#41;</a>&#41;:</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi mathvariant=normal >Σ</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi mathvariant=normal >Σ</mi><mi>j</mi></msub><msup><mi>A</mi><mo mathvariant=normal >′</mo></msup><mo>+</mo><msub><mi mathvariant=normal >Σ</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_{j+1} = A \Sigma_j A^\prime + \Sigma_u</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.969438em;vertical-align:-0.286108em;"></span><span class=mord ><span class=mord >Σ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.088em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">A</span><span class=mord ><span class=mord >Σ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mord ><span class="mord mathdefault">A</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Σ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> <p>Até convergência, onde <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> indexa a iteração. Veja que para o primeiro passo do algoritmo precisamos de um chute inicial Vamos construir uma função que faça isso. Nossa função vai receber:</p> <ol> <li><p>A matriz A</p> <li><p>A matriz <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi mathvariant=normal >Σ</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_u</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Σ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> </p> <li><p>A tolerância e o número máximo de iterações</p> </ol> <p>A tolerância é qual o tamanho da mudança entre as iterações <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j+1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span> necessários para o algoritmo parar: se a mudança for abaixo da tolerância, nós retornamos a matriz obtida como a matriz que resolver o problema.</p> <p>Nossa função vai receber os argumentos de &#40;3&#41; com nome, usando a sintaxe do <code>;</code>. Para o chute inicial nós vamos usar a matriz identidade, sempre. Esse chute é razoável porque, dada a nossa motivação &#40;calcular a matriz de variância covariância de um processo autoregressivo&#41;, nós gostariamos que uma solução atendesse a duas características: primeiro, simétrica; segundo, que todas as entradas na diagonal principal fossem positivas. A matriz identidade atende a essas propriedades. Para usar <code>I</code> como a matriz identidade &#40;como discutido na parte de Álgebra Linear&#41;, vamos precisar carregar o pacote <strong>LinearAlgebra</strong>. O coração da nossa função vai ser um <code>while</code> que, enquanto nós não alcançamos a convergência - ou o número máximo de iterações - que faz a conta da matriz <span class=katex ><span class=katex-mathml ><math><semantics><mrow><msub><mi mathvariant=normal >Σ</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma_x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Σ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> :</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> solve_lyapunov(A,Sigma;tol=<span class=hljs-number >1e-6</span>,iter_max=<span class=hljs-number >100</span>)
  err = <span class=hljs-number >1</span>
  j = <span class=hljs-number >1</span>
  sol = <span class=hljs-literal >I</span>
  <span class=hljs-keyword >while</span> j &lt;= iter_max &amp;&amp; err &gt; tol
  old_sol = sol
  sol = A*old_sol*A' + Sigma
  j += <span class=hljs-number >1</span>
  err = maximum(abs.(old_sol-sol))
  <span class=hljs-keyword >end</span>
  <span class=hljs-keyword >return</span> sol,j,err
<span class=hljs-keyword >end</span>
</code></pre> <p>Veja que eu escrevi a função de maneira que ela retorna três objetos: a matriz resultado, o número de iterações e o tamanho da diferença entre a última e a penúltima iteração. Vamos fazer um pequeno teste e mostrar as opções de como salvar os diferentes elementos que a função retorna:</p> <pre><code class="julia hljs">A=[<span class=hljs-number >0.5</span> <span class=hljs-number >0.2</span>;-<span class=hljs-number >0.4</span> <span class=hljs-number >0.6</span>]

solucao,tentativa,err = solve_lypaunov(A,<span class=hljs-literal >I</span>)
solucao = solve_lypaunov(A,<span class=hljs-literal >I</span>)
solucao,resto = solve_lypaunov(A,<span class=hljs-literal >I</span>)
solucao,resto = solve_lypaunov(A,<span class=hljs-literal >I</span>, iter_max=<span class=hljs-number >500</span>, tol = <span class=hljs-number >1e-10</span>)
</code></pre> <p>Veja que a matriz <span class=katex ><span class=katex-mathml ><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> atende as condições necessárias para o VAR ser estacionários &#40;o maior autovalor em módulo ser menor que 1&#41; e que em todos os exemplos eu coloquei a matriz identidade como a matriz de variância-covariância do erro. </p> <div class=page-foot > <div class=copyright > &copy; Daniel Coutinho. Last modified: July 29, 2019. Website built with <a href="https://github.com/tlienart/JuDoc.jl">JuDoc.jl</a>. </div> </div> </div> </div> </div> <script src="/Julia-Para-Economistas/libs/pure/ui.min.js"></script>